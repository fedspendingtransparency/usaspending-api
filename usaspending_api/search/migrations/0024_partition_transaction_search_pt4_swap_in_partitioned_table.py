# Generated by Django 3.2.15 on 2023-02-17 19:13
import logging
import re

from django.core.management import call_command
from django.db import migrations, connection
from typing import List

from usaspending_api.common.helpers.sql_helpers import is_table_partitioned, get_parent_partitioned_table

logger = logging.getLogger(__name__)

def swap_partitioned_table_with_partitions(apps, _):
    # Swap partitions first, then partition table
    call_command("swap_in_new_table", "--table=transaction_search_fabs", "--keep-old-data")
    call_command("swap_in_new_table", "--table=transaction_search_fpds", "--keep-old-data")
    call_command("swap_in_new_table", "--table=transaction_search", "--keep-old-data")


def undo_swap_partitioned_table_with_partitions(partition_names: List, assumed_parent_partitioned_table: str):
    # Do it in the same order as swapped (partitions first, then partitioned table)
    # Otherwise when cleanup of the "old" partitioned table deletes it,
    # it will cascade-delete its partitions, and prevent "un-swapping" them

    # Detach partitions before swapping out
    with connection.cursor() as cursor:
        is_parent_partitioned = is_table_partitioned(table=assumed_parent_partitioned_table, cursor=cursor)
        if not is_parent_partitioned:
            logger.warning(
                f"The assumed parent table '{assumed_parent_partitioned_table}' is NOT partitioned. "
                f"Finding parent, if exists, of each partition individually..."
            )
        for partition_name in partition_names:
            try_detach_partition(
                partition_name=partition_name,
                assumed_parent_partitioned_table=assumed_parent_partitioned_table,
                cursor=cursor
            )
            table_without_schema = re.sub(rf"^.*?\.(.*?)$", rf"\g<1>", partition_name)
            call_command("swap_in_new_table", f"--table={table_without_schema}", "--undo")
        parent_partition_without_schema = re.sub(rf"^.*?\.(.*?)$", rf"\g<1>", assumed_parent_partitioned_table)
        call_command("swap_in_new_table", f"--table={parent_partition_without_schema}", "--undo")


def try_detach_partition(partition_name, assumed_parent_partitioned_table, cursor):
    partition_parent = get_parent_partitioned_table(table=partition_name, cursor=cursor)
    if partition_parent is None:
        logger.warning(
            f"Table '{partition_name}', that is assumed to be a partition, is NOT. "
            "Will not attempt DETACH before undoing swap"
        )
    elif partition_parent != assumed_parent_partitioned_table:
        logger.warning(
            f"Table '{partition_name}' is ATTACHED to parent '{partition_parent}' "
            f"instead of assumed parent '{assumed_parent_partitioned_table}' "
            f"Will DETACH this partition from '{partition_parent}' instead, before undoing swap"
        )
        cursor.execute(f"ALTER TABLE {partition_parent} DETACH PARTITION {partition_name}")
    else:
        cursor.execute(f"ALTER TABLE {assumed_parent_partitioned_table} DETACH PARTITION {partition_name}")


class Migration(migrations.Migration):
    # call_command(...) issued from RunPython operations does not seem to have insight into the transaction state from
    # prior RunSQL operations. So in order to see tables or DB objects being created or dropped by prior RunSQL steps,
    # the migration steps need to be made non-atomic
    atomic = False

    dependencies = [
        ("search", "0023_partition_transaction_search_pt3_copy_metadata"),
    ]

    operations = [
        # STEP 1: Align constraints between tables to be swapped.
        migrations.RunSQL(
            sql="""
                ALTER TABLE rpt.transaction_search DROP CONSTRAINT IF EXISTS transaction_search_pkey;
                DROP INDEX IF EXISTS rpt.transaction_search_pkey;
            """,
            reverse_sql="""
                CREATE UNIQUE INDEX IF NOT EXISTS transaction_search_pkey ON rpt.transaction_search(transaction_id int8_ops);
            """,
        ),
        # STEP 2: Swap the partitions with data into the rpt schema in place of the empty/placeholder partitions
        #         This needs to be done as one Python function, so that if needing to be reversed, it can be called
        #         in reverse order.
        migrations.RunPython(
            atomic=True,
            code=swap_partitioned_table_with_partitions,
            reverse_code=lambda apps, _: undo_swap_partitioned_table_with_partitions(
                partition_names=["rpt.transaction_search_fabs", "rpt.transaction_search_fpds"],
                assumed_parent_partitioned_table="rpt.transaction_search"
            ),
        ),
    ]
